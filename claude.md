# 🎯 FSD (Feature-Sliced Design) 개요 및 기본 원칙

**FSD**는 프론트엔드 애플리케이션 구조를 위한 아키텍처 방법론입니다. 코드를 어떻게 분리하고 구성할지를 명확히 정의하여, **변화하는 비즈니스 요구 속에서도 프로젝트를 이해하기 쉽고 안정적으로 유지**할 수 있도록 돕습니다.

FSD는 단순한 규칙 집합이 아니라 실무를 위한 도구 체계(Linter, CLI, 예제 모음 등)도 함께 제공합니다. 언어, UI 프레임워크, 상태 관리 도구에 대한 제약은 없으며, Monorepo 환경에서도 점진적으로 적용할 수 있습니다.

## 💡 FSD의 근본적인 목적 (설계의 이유)

FSD가 구조화를 고민하는 궁극적인 이유는 **변화에 유연하게 대응**하기 위함입니다.
이는 하나의 기능이 변했을 때 다른 기능들이 그 변화의 영향을 받지 않도록 설계하는 것을 의미합니다.

이러한 유연한 설계를 달성하기 위해 FSD는 다음 두 가지 핵심 기준을 유지하려고 합니다:
1.  **높은 응집도 (High Cohesion)**.
2.  **낮은 결합도 (Low Coupling)**.

FSD는 **기능 중심**으로 폴더 구조를 짜는 방법론이며, 이는 곧 **관심사 분리**와 동일한 의미입니다.

---

## 1. FSD의 3단계 계층 구조: 레이어, 슬라이스, 세그먼트

FSD는 세 단계의 깊이(Depth)를 가지는 계층 구조를 따릅니다: **레이어** > **슬라이스** > **세그먼트**.

### A. 레이어 (Layer): 최상위 논리 계층

레이어는 모든 FSD 프로젝트의 표준 최상위 폴더이자 가장 큰 논리적인 계층 구조 단위입니다.

| 레이어 명칭 | 역할 및 기능 | 참고 |
| :--- | :--- | :--- |
| **App** | Routing, Entrypoint, Global Styles, Provider 등 앱을 실행하는 모든 요소 (전역 컴포넌트). | 모든 것을 참조할 수 있지만, 앱에서만 쓸 수 있습니다. |
| **Pages** | 전체 page 또는 중첩 Routing의 핵심 영역 (풀 페이지). | 위젯을 조합해서 만듭니다. |
| **Widgets** | 독립적으로 동작하는 대형 UI·기능 블록 (피처 또는 엔티티의 조합). | 재사용이 어렵고 한 번만 쓸 수 있는 것들을 묶습니다. (레이아웃으로 쓰기도 합니다). |
| **Features** | 제품 전반에서 재사용되는 비즈니스 기능. | **CUD/Mutation** 로직 및 유저 인터랙션이 있는 컴포넌트 (Clean FSD 기준). |
| **Entities** | user, product 같은 핵심 도메인 Entity (비즈니스 모델링 및 인터페이스). | **Read/Query** 로직 및 단순 뷰 역할 (Clean FSD 기준). |
| **Shared** | 프로젝트 전반에서 재사용되는 일반 유틸리티. | 프로젝트와 도메인에 상관없이 어디서나 쓸 수 있는 lib 함수나 Config 값들. |
| **Processes** | (더 이상 사용되지 않음). | 이전에는 페이지 간 복합 시나리오(스텝 바이 스텝)를 담당했습니다. |

**⭐ 레이어의 가장 중요한 규칙 (위계질서)**
상위 레이어의 모듈은 **자신보다 하위 레이어만 참조**할 수 있습니다. 이 임포트 관계에 명확한 위계질서가 있으며, 거꾸로(예: `Feature`가 `Widget`을 임포트)는 불가능합니다.

### B. 슬라이스 (Slice): 도메인 분리 단위

슬라이스는 레이어 내부를 **비즈니스 도메인별로** 나누는 단위입니다. 이는 도메인 중심 설계(예: User, Post, Comment)를 의미합니다.

*   **슬라이스를 도입한 배경:** 기능만 중심으로 폴더 구조를 짤 경우, 도메인 개념(예: `User`)이 여러 기능 폴더 하위에 중복되어 흩어지고 참조가 얽히게 되는 문제점(`폴더를 뛰어넘는 참조`)을 해결하기 위해서입니다.
*   **핵심 규칙:** **같은 레이어 내의 다른 슬라이스끼리는 서로 참조가 불가능**합니다. 이 규칙이 높은 응집도와 낮은 결합도를 보장합니다.
*   `App`과 `Shared` 레이어는 도메인의 구애를 받지 않아야 하므로, **슬라이스 없이 곧바로 세그먼트로 구성**됩니다.

### C. 세그먼트 (Segment): 역할별 그룹화

세그먼트는 슬라이스 및 `App` · `Shared` 레이어 하위에서 코드의 **기술적 목적** (역할)에 따라 코드를 그룹화하는 단위입니다. 익숙하지 않을 때는 이 역할 단위의 폴더가 분리를 수월하게 합니다.

| 세그먼트 명칭 | 역할 및 기능 |
| :--- | :--- |
| **ui** | UI components, styles 등 **UI 표현과 직접 관련된 코드**. |
| **api** | request functions, data types 등 **백엔드 통신 및 데이터 로직**. |
| **model** | schema, interfaces, store, **business logic** 등 애플리케이션 도메인 모델. |
| **lib** | 해당 슬라이스에서 여러 모듈이 함께 사용하는 **공통 라이브러리 코드**. |
| **config** | configuration files, feature flags 등 환경·기능 설정. |

---

## 2. Clean FSD로의 진화: 의도와 경계의 명확화

기존 FSD의 한계는 다음과 같았습니다:
1.  **레이어 경계의 모호성:** `Features` 레이어와 `Entities` 레이어의 구분이 모호했습니다.
2.  **코드 집중 현상:** `Features`에 너무 많은 콜 코드(Call Code)들이 몰리는 경향이 있었습니다.

이러한 한계를 극복하기 위해 **Clean FSD**가 등장했으며, 이는 **의도와 경계를 명확하게** 하는 것을 목표로 합니다.

### A. 쓰기(Features)와 읽기(Entities)의 분리 (CQRS 패턴 차용)

Clean FSD는 모호한 경계를 구분하기 위해 백엔드 아키텍처 패턴인 **CQRS (Command Query Responsibility Segregation)**에서 차용한 **쓰기 (Write)**와 **읽기 (Read)** 기준을 도입했습니다.

| 레이어 | 책임/기준 | 데이터 인터페이스 고려 사항 |
| :--- | :--- | :--- |
| **Features** | **쓰기 (CUD/Mutation)**. | **테이블을 분리**하는 구조가 업데이트나 확장(쓰기 활동)에 더 수월합니다. |
| **Entities** | **읽기 (R/Query)**. | **하나의 테이블에 계층적으로 데이터가 포함**되어야 읽기 과정에서 네트워크 라운드 트립이 줄어들어 수월합니다. |

### B. Clean FSD 적용 시 세그먼트별 코드 위치

읽기와 쓰기 기준이 명확해지면서 각 세그먼트의 역할이 명확해집니다:

| 세그먼트 | Features (쓰기 담당) | Entities (읽기 담당) |
| :--- | :--- | :--- |
| **API** | `Post`, `Put`, `Delete`와 같은 **변경 요청** 코드가 위치. | `Get` 관련 **조회 요청** 코드가 위치. |
| **UI** | **유저 인터랙션이 있는** 컴포넌트 (폼, 버튼, 인풋 등). | **유저 인터랙션이 없는** 단순 **뷰 (View)** 역할의 컴포넌트. |

---

## 3. Full-Stack 개발 환경에서의 FSD (Next.js 구현체)

Clean FSD는 단순히 폴더 구조를 개선하는 것을 넘어, 리액트 팀의 미래 개발 방향성인 **서버 퍼스트 (Server-First) 전략**과 깊이 연결되어 있습니다.

### A. 서버 퍼스트 전략과 FSD

리액트 팀은 클라이언트에서 JS가 실행되는 비율을 낮추고, DB 조작 및 렌더링까지 서버가 담당하는 서버 퍼스트 전략을 지향합니다.

*   **배경:** **RSC (React Server Component)**의 등장은 컴포넌트를 서버 환경에서 실행할 수 있게 하여 서버 퍼스트 전략의 첫걸음을 떼게 했습니다.
*   **Clean FSD 구현:** Clean FSD의 읽기/쓰기 분리 원칙은 이 전략의 구현체 역할을 합니다.
    *   **읽기 (Entities):** **RSC (React Server Component)**로 구현됩니다.
    *   **쓰기 (Features):** **폼 태그** (순수 HTML)와 **서버 액션 (Server Action)** 조합으로 구현됩니다.

Next.js는 RSC와 서버 액션을 디폴트로 쉽게 사용할 수 있게 제공하여, 클린 FSD 아키텍처를 구현하기 위한 효과적인 프레임워크이자 **구현체** 역할을 합니다.

### B. 온전한 기능 단위 개발

풀스택 개발이 가능해지면서 **온전한 기능 단위 개발**이 실현됩니다. 여기서 기능은 UI에서 출발하여 비즈니스 로직을 거쳐 **데이터베이스 조작까지** 일련의 프로세스를 전부 다 담당하는 것을 의미합니다.

*   기존에는 프론트 개발자의 역할이 API 호출 선언까지였지만, 풀스택 환경에서는 DB 조작까지 확장됩니다.

---

## 4. FSD의 장점 및 실무 규칙

### A. 주요 장점

FSD 구조는 다음과 같은 실무적 장점을 제공합니다:

*   **일관성:** 구조가 표준화되어 팀 간 협업과 신규 멤버 온보딩이 쉬워집니다.
*   **격리성:** 레이어와 슬라이스 간 의존성을 제한하여 특정 모듈만 안전하게 수정할 수 있습니다.
*   **재사용 범위 제어:** 재사용 가능한 코드를 필요한 범위에서만 활용하여 DRY 원칙과 실용성을 균형 있게 유지합니다.
*   **도메인 중심 구조:** 비즈니스 용어 기반의 구조로 되어 있어, 전체 코드를 몰라도 특정 기능을 독립적으로 구현할 수 있습니다.

### B. 캡슐화 및 팀 문화

FSD는 다음 규칙을 통해 캡슐화를 달성하고 팀의 일관성을 유지합니다:

1.  **캡슐화 (Encapsulation):** **`index.js` 또는 `index.ts` 파일을 적극적으로 사용**하여, 외부에 공개하고 싶은 컴포넌트만 익스포트합니다. 여기서 익스포트 하지 않은 컴포넌트는 프라이빗 컴포넌트가 되어 외부에서 쓸 수 없습니다.
2.  **임포트 방식:** 모든 임포트는 무조건 `index.js` (또는 `index.ts`)로 끝나야 합니다.
3.  **팀 문화 및 준수:** 모든 팀원이 FSD의 개념을 잘 알고 규칙(예: 레이어 간 임포트 위계질서)을 준수하고자 하는 마음이 있어야 합니다. 그렇지 않으면 규칙이 어겨져 구조가 무너질 수 있습니다.

---

## 5. FSD 적용 시 고려 사항

*   **규모:** 프로젝트 규모가 커져서 폴더 구조가 너무 복잡해지고 머리 아플 때 적용할 가치가 높습니다. 몇 페이지짜리 간단한 서비스에서는 굳이 적용하지 않아도 됩니다.
*   **진입 장벽:** 규칙이 많기 때문에 진입 장벽이 있을 수 있습니다.
*   **점진적 도입:** 기존 프로젝트에서는 `app`, `shared` 레이어를 먼저 정리하며 기반을 다지고, 이후 `widgets`, `pages`로 UI를 분배하며 점진적으로 FSD를 적용할 수 있습니다.

---

## 6. AI와의 효율적인 협업 (엔지니어를 위한 바이브 코딩)

Clean FSD는 의도와 경계가 명확한 설계를 제공하므로, **AI와의 협업 효율성을 극대화**할 수 있습니다.

*   엔지니어는 AI에게 프롬프트를 입력할 때, FSD 구조를 활용하여 경로, 로직 함수 이름 등을 명확하게 지정할 수 있습니다.
*   의도가 명확히 전달되므로 수정할 필요가 대폭 줄어들고 작업 생산성이 올라갑니다.
*   경계가 명확하게 나뉘어 있어, 정해진 폴더 구조 안에서만 작업이 이루어지므로 내가 모르는 작업이 일어나지 않습니다.

---

## 7. 현재 프로젝트 적용 사항 (i18nexus-demo)

### 현재 프로젝트 구조

```
i18nexus-demo/
├── app/                    # Next.js App Router
│   ├── components/        # 공유 컴포넌트 (Shared Layer)
│   ├── page.tsx          # 랜딩 페이지
│   └── ...
├── locales/              # 다국어 번역 파일
└── lib/                  # 유틸리티 및 헬퍼 함수
```

### 향후 Clean FSD 적용 방향

현재는 전통적인 Next.js 구조를 따르고 있으나, 향후 확장 시 Clean FSD 원칙을 적용할 수 있습니다:

```
app/
├── _entities/           # 읽기 담당 (Entities Layer)
│   ├── translation/     # 번역 도메인
│   │   ├── api/        # GET 요청
│   │   ├── model/      # 데이터 모델
│   │   └── ui/         # View 컴포넌트 (인터랙션 없음)
│   └── download/       # 다운로드 통계 도메인
│       ├── api/
│       └── ui/
├── _features/          # 쓰기 담당 (Features Layer)
│   ├── language-switch/  # 언어 전환 기능
│   │   ├── ui/          # Form, Button (인터랙션 있음)
│   │   └── action/      # Server Action
│   └── project-submit/   # 프로젝트 제출 기능
│       ├── ui/
│       └── action/
├── _shared/            # 공유 레이어
│   ├── ui/            # 공통 UI 컴포넌트
│   ├── lib/           # 유틸리티
│   └── api/           # API 클라이언트
└── (pages)/           # Next.js 페이지 라우팅
    ├── page.tsx
    ├── getting-started/
    └── docs/
```

### 핵심 원칙 적용 예시

#### ✅ 읽기 (Entities)
- **위치**: `app/_entities/download/`
- **역할**: NPM 다운로드 통계 조회
- **구현**:
  - `api/getDownloadStats.ts` - GET 요청
  - `ui/DownloadStatsView.tsx` - RSC로 구현된 View

#### ✅ 쓰기 (Features)
- **위치**: `app/_features/project-submit/`
- **역할**: 쇼케이스 프로젝트 제출
- **구현**:
  - `ui/ProjectSubmitForm.tsx` - 폼 컴포넌트
  - `action/submitProject.ts` - Server Action (POST)

이러한 구조는 향후 기능 확장 시 적용 가능하며, 현재는 데모 프로젝트의 특성상 전통적인 구조를 유지하고 있습니다.
